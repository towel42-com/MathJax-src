#! /usr/bin/env node

/*************************************************************
 *
 *  Copyright (c) 2018-2025 The MathJax Consortium
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/**
 * @fileoverview  webpack the component in the current directory
 *
 * @author dpvc@mathjax.org (Davide Cervone)
 */

const fs = require('fs');
const path = require('path');
const {spawn} = require('child_process');

/**
 * The module type to use ('cjs' or 'mjs')
 */
const target = (process.argv[2] || 'mjs')

/**
 * The bundle directory name
 */
const bundle = (process.argv[3] || 'bundle');

/**
 * @param {string} name    The file name to turn into a Regular expression
 * @return {RegExp}        The regular expression for the name,
 */
function fileRegExp(name) {
  return new RegExp(name.replace(/([\\.{}[\]()?*+^$])/g, '\\$1'), 'g');
}

/**
 * @param {Object}    The file or asset data whose size is to be returned
 * @return {string}   The string giving the size in KB
 */
function fileSize(file) {
  return ' (' + (file.size / 1024).toFixed(2).replace(/\.?0+$/, '') + ' KB)';
}

/**
 * Regular expressions for the components directory and the MathJax .js location
 */
const compPath = path.dirname(__dirname);
const mjPath = path.dirname(compPath);
const jsPath = path.join(__dirname, '..', '..', target);
const compRE = fileRegExp(compPath);
const rootRE = fileRegExp(path.dirname(jsPath));
const nodeRE = /^.*\/node_modules/;
const fontRE = new RegExp('^.*\\/(mathjax-[^\/-]*)(?:-font)?\/(build|[cm]js)');

const packDir = process.cwd();

/**
 * @param {string} dir   The directory to pack
 * @return {JSON}   The parsed JSON from webpack
 */
async function readJSON(dir) {
  return new Promise((ok, fail) => {
    const buffer = [];
    const child = spawn(
      'npx',
      [
        'webpack',
        '--env', `dir=${path.relative(packDir, path.resolve(dir))}`,
        '--env', `bundle=${bundle}`,
        '--json',
        '-c', path.relative(packDir, path.join(compPath, 'webpack.config.' + target))
      ],
      {
        cwd: packDir,
        shell: true,
      }
    );
    child.stdout.on('data', (data) => buffer.push(String(data)));
    child.stderr.on('data', (data) => console.error(String(data)));
    child.on('close', (code) => {
      if (code !== 0) {
        fail('Webpack failed with code ' + code);
        return;
      }
      const json = JSON.parse(buffer.join(''));
      if (json.errors && json.errors.length) {
        fail(json.errors[0].message);
      }
      ok(json);
    });
  });
}

/**
 * Run webpack if there is a configuration file for it
 *
 * @param {string} dir   The directory to pack
 */
async function webpackLib(dir) {
  try {
    const dirRE = fileRegExp(path.resolve(dir));

    //
    // Get js directory from the webpack.config.js file
    //
    let config = require(path.resolve(dir, 'config.json')).webpack;
    if (!config) return;
    const jsdir = (config.js ? path.resolve(dir, config.js).replace(/js$/, target) : jsPath);
    const jsRE = fileRegExp(jsdir);
    const jsRE2 = (config.js ? fileRegExp(path.resolve(dir, config.js)) : /^$/);
    const libRE = fileRegExp(path.resolve(jsdir, '..', 'components'));

    //
    // Get the json from webpack and print the asset name and size
    //
    const json = await readJSON(dir);
    for (const asset of json.assets) {
      console.log(asset.name + fileSize(asset));
    }
    //
    // Sort the modules and print their names and sizes
    //
    const modules = json.modules;
    for (const module of modules) {
      module.name = path.resolve(dir, module.name)
        .replace(/ \+ \d+ modules/, '')
        .replace(dirRE, '.');
    }
    const list = [];
    for (const module of modules) {
      if (module.moduleType.match(/javascript|json/)) {
        let name = (module.nameForCondition || module.name)
            .replace(compRE, '[components]')
            .replace(nodeRE, '[node]')
            .replace(rootRE, '[mathjax]')
            .replace(fontRE, '[$1]/$2')
            .replace(jsRE,   '[js]')
            .replace(jsRE2,  '[js]')
            .replace(libRE,  '[build]');
        if (name.charAt(0) !== '.' && name.charAt(0) !== '[') {
          name = path.relative(dir, name);
        }
        list.push('  ' + name + fileSize(module));
      }
    }
    console.log(
      list
        .filter(a => a.slice(2, 4) === './').sort()
        .concat(list.filter(a => a.slice(2, 4) !== './').sort())
        .join('\n')
    );
  } catch (err) {
    console.error(err);
  }
}

webpackLib(process.argv[4] || '.');
